<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/e31a0ba45e9cd4c5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e31a0ba45e9cd4c5.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-8d78bf989db74c8f.js" defer=""></script><script src="/_next/static/chunks/main-1821e004852d5bbe.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3ece3fcb67bcafcc.js" defer=""></script><script src="/_next/static/chunks/0d3c041e-907c9cc4e083b512.js" defer=""></script><script src="/_next/static/chunks/112-aa8fc9a74ae1b5e5.js" defer=""></script><script src="/_next/static/chunks/pages/Blogs/%5Bblog%5D-14625b2dcfa521cc.js" defer=""></script><script src="/_next/static/1eWxrH7L-T8xdp2JVm_z4/_buildManifest.js" defer=""></script><script src="/_next/static/1eWxrH7L-T8xdp2JVm_z4/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex bg-blue-700 flex-col items-center w-screen h-screen gap-8 text-justify"><nav class="nav w-full h-max p-2 flex shadow-2xl relative z-50 justify-between bg-blue-300"><h1 class="text-3xl z-50 text-gray-800 font-bold">Next SSG</h1><ul class="flex p-1 gap-6 font-bold text-white text-2xl"><a class=" hover:text-red-600 cursor-pointer" href="/">Home</a><a class=" hover:text-red-600 cursor-pointer" href="/Blogs">Blogs</a><a class=" hover:text-red-600 cursor-pointer" href="/Profiles">Profiles</a><a class=" pr-8 hover:text-red-600 cursor-pointer" href="/About">About</a></ul></nav><div class="flex font-bold flex-col gap-8 items-center lg:w-4/5 lg:h-4/5 w-11/12 h-full main overflow-y-auto p-8 text-justify bg-white shadow-3xl rounded-xl"><h1 class="text-4xl text-red-600">useEffect Hook – Reactjs</h1><h1 class="text-lg first-letter:text-3xl">             <!-- -->React Hooks are the feature that was introduced in React version 16.8, allowing us to use state and other class components features in our functional components. Out of all the hooks introduced, there is one salient hook named the UseEffect.</h1><h1 class="text-lg first-letter:text-3xl">             <!-- -->The useEffect hook is a boon for the functional components. It basically allows us to execute side effects in our functional components. Side effects here are referring to api calls to the backend server, interacting with browser APIs, i.e. using document or window, and unanticipated timer functions such as setTimeout and setInterval. In short, the side effects are those whose results are in general unpredictable.However, we can perform side effects without using the mentioned hook within the component body itself.</h1><h1 class="text-lg first-letter:text-3xl">             <!-- -->Here we are making an API call in the document body. It might not throw an error , but would definitely hamper the rendering process, which is why this is not the right technique. We can make use of useEffect for these side effects.Below are the steps to use the UseEffect hook in our functional components:Import it from “react”Call it above the returned JSX </h1><h1 class="text-xl first-letter:text-3xl">             <!-- -->There are two state variables; counter and inputValue. Counter state variable is being updated with the click of the Increment button. And whenever we would increment the value of counter the console in the useEffect hook will be printed. The reason being, we have passed the counter state variable in the dependency array parameter of the useEffect hook.On the other hand, the same hook won’t be called whenever we update the inputValue variable, since we haven’t passed it in the array parameter. If we would have done so, the console in useEffect would have been called on both the state variables updation i.e., the counter and the inputValue variable.useEffect provides the functionality of three life cycle methods to the functional components:componentDidMount()Once we pass an empty array as a second parameter in the useEffect hook, it runs only once, i.e. at the time of component mounting.</h1><h1 class="text-xl first-letter:text-3xl pb-6">             <!-- -->Here, the console in the function returned from useEffect will be called when the component unmounts.Hence, any necessary action to be performed during unmounting can be performed here.Principally, actions in unmounting are executed to perform cleanup. Cleanup here is referring to cleaning up the code before the component gets unmounted for ex., clearing the interval. The cleanup can prevent memory leaks and remove unwanted things.Some use-cases for the same are:</h1><h1 class="text-4xl text-red-600">Happy Codding!!</h1></div><div class="relative w-full mt-10"><footer class="z-50"><h1 class="font-bold w-full text-center absolute bottom-0 p-2 shadow-2xl z-50 text-xl bg-gray-800 text-blue-100 hover:text-red-600"> Designed &amp; Developed By ©Yash Simejiya</h1></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":[{"_id":"63809102d82caf87b72114e9","subject":"useEffect Hook – Reactjs","short_description":"React Hooks are the feature that was introduced in React version 16.8, allowing us to use state and other class components features in our functional components. Out of all the hooks introduced, there is one salient hook named the UseEffect.","short_description_para_1":"The useEffect hook is a boon for the functional components. It basically allows us to execute side effects in our functional components. Side effects here are referring to api calls to the backend server, interacting with browser APIs, i.e. using document or window, and unanticipated timer functions such as setTimeout and setInterval. In short, the side effects are those whose results are in general unpredictable.However, we can perform side effects without using the mentioned hook within the component body itself.","short_description_para_2":"Here we are making an API call in the document body. It might not throw an error , but would definitely hamper the rendering process, which is why this is not the right technique. We can make use of useEffect for these side effects.Below are the steps to use the UseEffect hook in our functional components:Import it from “react”Call it above the returned JSX ","short_description_para_3":"There are two state variables; counter and inputValue. Counter state variable is being updated with the click of the Increment button. And whenever we would increment the value of counter the console in the useEffect hook will be printed. The reason being, we have passed the counter state variable in the dependency array parameter of the useEffect hook.On the other hand, the same hook won’t be called whenever we update the inputValue variable, since we haven’t passed it in the array parameter. If we would have done so, the console in useEffect would have been called on both the state variables updation i.e., the counter and the inputValue variable.useEffect provides the functionality of three life cycle methods to the functional components:componentDidMount()Once we pass an empty array as a second parameter in the useEffect hook, it runs only once, i.e. at the time of component mounting.","short_description_para_4":"Here, the console in the function returned from useEffect will be called when the component unmounts.Hence, any necessary action to be performed during unmounting can be performed here.Principally, actions in unmounting are executed to perform cleanup. Cleanup here is referring to cleaning up the code before the component gets unmounted for ex., clearing the interval. The cleanup can prevent memory leaks and remove unwanted things.Some use-cases for the same are:","__v":0}]},"__N_SSG":true},"page":"/Blogs/[blog]","query":{"blog":"63809102d82caf87b72114e9"},"buildId":"1eWxrH7L-T8xdp2JVm_z4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>